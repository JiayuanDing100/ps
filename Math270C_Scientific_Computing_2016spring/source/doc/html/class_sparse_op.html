<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>270C_Classes: SparseOp&lt; Vtype &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">270C_Classes
   </div>
   <div id="projectbrief">Classes for Math 270</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sparse_op-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseOp&lt; Vtype &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sparse matrix representation of finite dimensional linear operators.  
 <a href="class_sparse_op.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sparse_op_8h_source.html">SparseOp.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac67e19620e2de02d72a5e4b06f371d73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ac67e19620e2de02d72a5e4b06f371d73">SparseOp</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;S)</td></tr>
<tr class="separator:ac67e19620e2de02d72a5e4b06f371d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918d6d7ac37d80ddec7d6b1374ccd885"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a918d6d7ac37d80ddec7d6b1374ccd885">SparseOp</a> (long rowDimension, long colDimension, double dropTolerance=0.0)</td></tr>
<tr class="separator:a918d6d7ac37d80ddec7d6b1374ccd885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accec200d2eb3737307ea2319a2ed338f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#accec200d2eb3737307ea2319a2ed338f">SparseOp</a> (long rowDimension, long colDimension, long initialRowSize, double rowExpansionFactor, double dropTolerance=0.0)</td></tr>
<tr class="separator:accec200d2eb3737307ea2319a2ed338f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad755fc44765bfc95a1fa7db1855eae5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ad755fc44765bfc95a1fa7db1855eae5c">initialize</a> ()</td></tr>
<tr class="separator:ad755fc44765bfc95a1fa7db1855eae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede9fff8c3c894b76ee27132ad3cddee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#aede9fff8c3c894b76ee27132ad3cddee">initialize</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;S)</td></tr>
<tr class="separator:aede9fff8c3c894b76ee27132ad3cddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4996dbca71470616592a52bfd9999202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a4996dbca71470616592a52bfd9999202">initialize</a> (long rowDimension, long colDimension, double dropTolerance=0.0)</td></tr>
<tr class="separator:a4996dbca71470616592a52bfd9999202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e6e842abf89e903ee55d32c2664ae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ab5e6e842abf89e903ee55d32c2664ae3">initialize</a> (long rowDimension, long colDimension, long initialRowSize, double rowExpansionFactor, double dropTolerance=0.0)</td></tr>
<tr class="separator:ab5e6e842abf89e903ee55d32c2664ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c46197946c939959c4404092b5ec7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a08c46197946c939959c4404092b5ec7d">setOperatorData</a> (long rowIndex, long colIndex, double coeffValue)</td></tr>
<tr class="separator:a08c46197946c939959c4404092b5ec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae326121aea447c430b56fa20b81134d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ae326121aea447c430b56fa20b81134d5">operator()</a> (long i, long j)</td></tr>
<tr class="separator:ae326121aea447c430b56fa20b81134d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b8751d04845538599645ab2a0e955a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b8751d04845538599645ab2a0e955a"></a>
const <a class="el" href="class_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (long i, long j) const </td></tr>
<tr class="separator:a82b8751d04845538599645ab2a0e955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3708557ac0fb3ea81a984b76613e96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a5b3708557ac0fb3ea81a984b76613e96">apply</a> (Vtype &amp;V)</td></tr>
<tr class="separator:a5b3708557ac0fb3ea81a984b76613e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fdcb8e87b710622a73b1589f719b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a06fdcb8e87b710622a73b1589f719b57">apply</a> (const Vtype &amp;Vin, Vtype &amp;Vout) const </td></tr>
<tr class="separator:a06fdcb8e87b710622a73b1589f719b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2106786adf2f6a857a737d7eda0c135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ac2106786adf2f6a857a737d7eda0c135">applyTranspose</a> (Vtype &amp;V)</td></tr>
<tr class="separator:ac2106786adf2f6a857a737d7eda0c135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1d3be0453f2ed08356c9d34abf4bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#abd1d3be0453f2ed08356c9d34abf4bd6">applyTranspose</a> (const Vtype &amp;Vin, Vtype &amp;Vout) const </td></tr>
<tr class="separator:abd1d3be0453f2ed08356c9d34abf4bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894ed96884e61dae81e0add1f63557ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a894ed96884e61dae81e0add1f63557ba"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>getRowDimension</b> () const </td></tr>
<tr class="separator:a894ed96884e61dae81e0add1f63557ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93344db045d27119a788dd93e7183123"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93344db045d27119a788dd93e7183123"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>getColDimension</b> () const </td></tr>
<tr class="separator:a93344db045d27119a788dd93e7183123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ece1f0dc9d4d3080a7824b6b3b995b3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a1ece1f0dc9d4d3080a7824b6b3b995b3">getTotalDataCount</a> () const </td></tr>
<tr class="separator:a1ece1f0dc9d4d3080a7824b6b3b995b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05d87a8b57e671db076f5bff48ff09b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ae05d87a8b57e671db076f5bff48ff09b">getTotalDroppedCount</a> () const </td></tr>
<tr class="separator:ae05d87a8b57e671db076f5bff48ff09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b5c358ad6bfd251cd57e6d46a8bf1e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a50b5c358ad6bfd251cd57e6d46a8bf1e">getTotalInitialCount</a> () const </td></tr>
<tr class="separator:a50b5c358ad6bfd251cd57e6d46a8bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb66a97025838deaac9554e65c58e39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#aedb66a97025838deaac9554e65c58e39">printMatrix</a> (std::string format=&quot;%10.5e&quot;) const </td></tr>
<tr class="separator:aedb66a97025838deaac9554e65c58e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885f7e0ded73ead4a67e9d048b7179f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a885f7e0ded73ead4a67e9d048b7179f0">operator=</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;rhs)</td></tr>
<tr class="separator:a885f7e0ded73ead4a67e9d048b7179f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f4eec670d91a94d95c1ed1552175bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#af5f4eec670d91a94d95c1ed1552175bc">operator+=</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;rhs)</td></tr>
<tr class="separator:af5f4eec670d91a94d95c1ed1552175bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58a24d7a320005a764a8ef80dcd5e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#aad58a24d7a320005a764a8ef80dcd5e2">operator+</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;rhs) const </td></tr>
<tr class="separator:aad58a24d7a320005a764a8ef80dcd5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542a0c6c68e7b0cd0fe6e0c78893f7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a542a0c6c68e7b0cd0fe6e0c78893f7b7">operator*=</a> (const double a)</td></tr>
<tr class="separator:a542a0c6c68e7b0cd0fe6e0c78893f7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40641e437047fffe0039e3a2d2e07ca5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a40641e437047fffe0039e3a2d2e07ca5">operator*</a> (const double a)</td></tr>
<tr class="separator:a40641e437047fffe0039e3a2d2e07ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb49fdd7ab7ec59a3097a393cb9d5738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#abb49fdd7ab7ec59a3097a393cb9d5738">operator-=</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;rhs)</td></tr>
<tr class="separator:abb49fdd7ab7ec59a3097a393cb9d5738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd0e808c7300e2cd01b86c7150ec679"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a4cd0e808c7300e2cd01b86c7150ec679">operator-</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;rhs) const </td></tr>
<tr class="separator:a4cd0e808c7300e2cd01b86c7150ec679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7348a2205d31179717e6dd7dea0694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a8e7348a2205d31179717e6dd7dea0694">operator*=</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;rhs)</td></tr>
<tr class="separator:a8e7348a2205d31179717e6dd7dea0694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaab6ee7430484d85a0939b4d897a2d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#abaaab6ee7430484d85a0939b4d897a2d">operator*</a> (const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;rhs) const </td></tr>
<tr class="separator:abaaab6ee7430484d85a0939b4d897a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36745b2b5b9ae5226e6f30735de16376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a36745b2b5b9ae5226e6f30735de16376">createTranspose</a> (<a class="el" href="class_sparse_op.html">SparseOp</a> &amp;S) const </td></tr>
<tr class="separator:a36745b2b5b9ae5226e6f30735de16376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89af1c1551794a871da20563e92813c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a89af1c1551794a871da20563e92813c7">createLowerTriComponent</a> (<a class="el" href="class_sparse_op.html">SparseOp</a> &amp;L)</td></tr>
<tr class="separator:a89af1c1551794a871da20563e92813c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18997d43b37bf292ce2315252459726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ab18997d43b37bf292ce2315252459726">createUpperTriComponent</a> (<a class="el" href="class_sparse_op.html">SparseOp</a> &amp;U)</td></tr>
<tr class="separator:ab18997d43b37bf292ce2315252459726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6456cd623458d91b4190a6b0fd112e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a6456cd623458d91b4190a6b0fd112e55">createDiagComponent</a> (<a class="el" href="class_sparse_op.html">SparseOp</a> &amp;D)</td></tr>
<tr class="separator:a6456cd623458d91b4190a6b0fd112e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775ecb4ffd234d17bd2c407cef05cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ac775ecb4ffd234d17bd2c407cef05cd0">applyLowerTriInverse</a> (Vtype &amp;V)</td></tr>
<tr class="separator:ac775ecb4ffd234d17bd2c407cef05cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81647d9261fd988f57455dd8ae5491e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#af81647d9261fd988f57455dd8ae5491e">applyUpperTriInverse</a> (Vtype &amp;V)</td></tr>
<tr class="separator:af81647d9261fd988f57455dd8ae5491e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1da7fa4c808b143397f6effd5ec0d27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ae1da7fa4c808b143397f6effd5ec0d27">sortColumnIndices</a> ()</td></tr>
<tr class="separator:ae1da7fa4c808b143397f6effd5ec0d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab334dc0eebd2a6d1b01175e5ed5aae6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#ab334dc0eebd2a6d1b01175e5ed5aae6f">compact</a> ()</td></tr>
<tr class="separator:ab334dc0eebd2a6d1b01175e5ed5aae6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d126b1dae39b2b6ea99fcee78aa435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a21d126b1dae39b2b6ea99fcee78aa435">printMatrixStructure</a> () const </td></tr>
<tr class="separator:a21d126b1dae39b2b6ea99fcee78aa435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa908e37b595198e81dfadebbf73371e5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#aa908e37b595198e81dfadebbf73371e5">getInitialRowSize</a> () const </td></tr>
<tr class="separator:aa908e37b595198e81dfadebbf73371e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf1f94bcefa9079900ab341f33ac428"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#abdf1f94bcefa9079900ab341f33ac428">getRowExpansionFactor</a> () const </td></tr>
<tr class="separator:abdf1f94bcefa9079900ab341f33ac428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eca79d4d3f79e7ea672b77878840449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a2eca79d4d3f79e7ea672b77878840449">getOperatorAsDenseMatrix</a> (double *S) const </td></tr>
<tr class="separator:a2eca79d4d3f79e7ea672b77878840449"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0a5df52b1241d98efc2196b6571df336"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sparse_op.html#a0a5df52b1241d98efc2196b6571df336">operator*</a> (const double a, const <a class="el" href="class_sparse_op.html">SparseOp</a> &amp;X)</td></tr>
<tr class="separator:a0a5df52b1241d98efc2196b6571df336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Vtype&gt;<br/>
class SparseOp&lt; Vtype &gt;</h3>

<p>Sparse matrix representation of finite dimensional linear operators. </p>
<p>This is not a general sparse matrix class, and it's primary purpose is to collect the non-zero entries of a matrix representation of the operator in such a way that the application of the operator to a one dimensional vector is carried out in a computationally efficient manner with minimal storage requirements.</p>
<p>This class is templated with respect to a vector class <b>Vtype</b>.</p>
<p><b>Vtype</b> is a singly indexed vector class with (minimally) the following member functions:</p>
<pre>
Vtype()                            (null constructor)
initialize(const Vtype&amp;)           (copy initializer)
operator =                         (duplicate assignment)
long getSize()                     (Returns the size (dimension) of the vector)
</pre><p>Usage Notes:</p>
<p>!!! Indexing starts at 0 for each matrix entry !!!</p>
<p>Each row is repacked to an array of minimal size when consecutive calls to operator()(i,j) or setOperatorData(...) are called with row indices that differ. To avoid extraneous copying due to repacking, one should loop through the data assignment with the second index running the fastest, for example if S is the <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> instance then</p>
<pre>
for(i = 0; i &lt; N; i++)
{
for(j = 0; j &lt; N; j++)
{
  value =  *** computation of value ***</pre><pre>  S(i,j) = value;
}}
</pre><p>To improve performance by reducing the memory size and increasing locality of memory access, the member function <a class="el" href="class_sparse_op.html#ab334dc0eebd2a6d1b01175e5ed5aae6f">compact()</a> can be called followed by <a class="el" href="class_sparse_op.html#ae1da7fa4c808b143397f6effd5ec0d27">sortColumnIndices()</a>. This combination of calls requires O(M) operations where M is the number of non-zero entries in the matrix.</p>
<dl class="section author"><dt>Author</dt><dd>Chris Anderson (UCLA) Created for Math 270C from A fork of RC_SparseOp.h created by C. Anderson and R. Compton. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>4/22/15 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac67e19620e2de02d72a5e4b06f371d73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::<a class="el" href="class_sparse_op.html">SparseOp</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Create a duplicate instance. </p>

</div>
</div>
<a class="anchor" id="a918d6d7ac37d80ddec7d6b1374ccd885"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::<a class="el" href="class_sparse_op.html">SparseOp</a> </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dropTolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty sparse representation of sparse matrix of size rowDimension X colDimension. If a non-zero dropTolerance value is specified any element specified with an absolute value less dropTolerance is ignored. </p>

</div>
</div>
<a class="anchor" id="accec200d2eb3737307ea2319a2ed338f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::<a class="el" href="class_sparse_op.html">SparseOp</a> </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialRowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rowExpansionFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dropTolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty sparse representation of sparse matrix of size rowDimension X colDimension. initialRowSize is an estimated number of non-zero elements per row. rowExpansionFactor, is the multiplicative factor used to increase row storage, when the the allocated storage for a particular row is exceeded.</p>
<p>If a non-zero dropTolerance value is specified any element specified with an absolute value less dropTolerance is ignored. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5b3708557ac0fb3ea81a984b76613e96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the input vector instance V with the values of S*V where S is this sparse operator instance. The row and column dimensions of S must be equal.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="a06fdcb8e87b710622a73b1589f719b57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Vtype &amp;&#160;</td>
          <td class="paramname"><em>Vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>Vout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites Vout with the values of S*Vin where S is this sparse operator instance.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="ac775ecb4ffd234d17bd2c407cef05cd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::applyLowerTriInverse </td>
          <td>(</td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the input vector instance V with the solution of the linear system associated with the lower triangular part of S that includes the diagonal. The values in the upper triangular part of S, excluding the diagonal, are ignored.</p>
<p>This method assumes that all diagonals of the matrix are non-zero.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked </p>

</div>
</div>
<a class="anchor" id="ac2106786adf2f6a857a737d7eda0c135"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::applyTranspose </td>
          <td>(</td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the input vector instance V with the values of (transpose S)*V where S is this sparse operator instance. The row and column dimensions of S must be equal.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="abd1d3be0453f2ed08356c9d34abf4bd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::applyTranspose </td>
          <td>(</td>
          <td class="paramtype">const Vtype &amp;&#160;</td>
          <td class="paramname"><em>Vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>Vout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the vector instance Vout with the values of (transpose S)*Vin where S is this sparse operator instance.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="af81647d9261fd988f57455dd8ae5491e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::applyUpperTriInverse </td>
          <td>(</td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the input vector instance V with the solution of the linear system associated with the upper triangular part of S that includes the diagonal. The values in the lower triangular part of S, excluding the diagonal, are ignored.</p>
<p>This method assumes that all diagonals of the matrix are non-zero.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked </p>

</div>
</div>
<a class="anchor" id="ab334dc0eebd2a6d1b01175e5ed5aae6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This routine removes extraneous data that has been pre-allocated for each row. </p>

</div>
</div>
<a class="anchor" id="a6456cd623458d91b4190a6b0fd112e55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::createDiagComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method initializes the input <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> argument with the diagonal component of the invoking instance, e.g. e.g. the D part of the decomposition A = L + D + U </p>

</div>
</div>
<a class="anchor" id="a89af1c1551794a871da20563e92813c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::createLowerTriComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method initializes the input <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> argument with the lower triangular component of the invoking instance, e.g. e.g. the L part of the decomposition A = L + D + U</p>
<p>The diagonal is NOT included, </p>

</div>
</div>
<a class="anchor" id="a36745b2b5b9ae5226e6f30735de16376"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::createTranspose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method initializes the input <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> argument with the transpose of the invoking instance. </p>

</div>
</div>
<a class="anchor" id="ab18997d43b37bf292ce2315252459726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::createUpperTriComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method initializes the input <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> argument with the upper triangular component of the invoking instance, e.g. e.g. the U part of the decomposition A = L + D + U</p>
<p>The diagonal is NOT included, </p>

</div>
</div>
<a class="anchor" id="aa908e37b595198e81dfadebbf73371e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::getInitialRowSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the initial estimate of the number of non-zero elements per row. </p>

</div>
</div>
<a class="anchor" id="a2eca79d4d3f79e7ea672b77878840449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::getOperatorAsDenseMatrix </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A low level utility routine to extract the matrix data as a singly indexed double array. This routine packs a double array S with the values of the dense matrix representation of the operator. The data is stored by rows (C convention).</p>
<p>The input argument S is a pointer to an existing double array of size rowCount*colCount.</p>
<p>The (i,j)th element of the dense matrix can be accessed using</p>
<pre>
Sij =  S[j+ i*colCount]
</pre> 
</div>
</div>
<a class="anchor" id="abdf1f94bcefa9079900ab341f33ac428"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::getRowExpansionFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the multiplicative factor when the storage from a given row must be re-allocated. </p>

</div>
</div>
<a class="anchor" id="a1ece1f0dc9d4d3080a7824b6b3b995b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::getTotalDataCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of non-zero elements in the matrix </p>

</div>
</div>
<a class="anchor" id="ae05d87a8b57e671db076f5bff48ff09b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::getTotalDroppedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of non-zero elements that were ignored </p>

</div>
</div>
<a class="anchor" id="a50b5c358ad6bfd251cd57e6d46a8bf1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::getTotalInitialCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of calls to the setOperatorData(...) member function. </p>

</div>
</div>
<a class="anchor" id="ad755fc44765bfc95a1fa7db1855eae5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Null initializer. All allocated memory is freed. </p>

</div>
</div>
<a class="anchor" id="aede9fff8c3c894b76ee27132ad3cddee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy initializer. Initializes a duplicate instance. </p>

</div>
</div>
<a class="anchor" id="a4996dbca71470616592a52bfd9999202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dropTolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty sparse representation of sparse matrix of size rowDimension X colDimension. If a non-zero dropTolerance value is specified any element specified with an absolute value less dropTolerance is ignored. </p>

</div>
</div>
<a class="anchor" id="ab5e6e842abf89e903ee55d32c2664ae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialRowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rowExpansionFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dropTolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty sparse representation of sparse matrix of size rowDimension X colDimension. initialRowSize is an estimated number of non-zero elements per row. rowExpansionFactor, is the multiplicative factor used to increase row storage, when the the allocated storage for a particular row is exceeded.</p>
<p>If a non-zero dropTolerance value is specified any element specified with an absolute value less dropTolerance is ignored. </p>

</div>
</div>
<a class="anchor" id="ae326121aea447c430b56fa20b81134d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a> <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When used to extract the (i,j)th element, the <a class="el" href="class_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a> value returned is automatically converted to the (i,j)th value of the <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> matrix. If the (i,j)th element of the <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> instance has not been set, then the <a class="el" href="class_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a> is converted to the value 0.0.</p>
<p>When used to assign the (i,j)th element, this member function sets the (i,j)th element to the specified value.</p>
<p>If _DEBUG is defined then index bounds checking is performed. </p>

</div>
</div>
<a class="anchor" id="a40641e437047fffe0039e3a2d2e07ca5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sparse_op.html">SparseOp</a> <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication </p>

</div>
</div>
<a class="anchor" id="abaaab6ee7430484d85a0939b4d897a2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sparse_op.html">SparseOp</a> <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (matrix) product of two <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> instances.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="a542a0c6c68e7b0cd0fe6e0c78893f7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Incremental scalar multiplication </p>

</div>
</div>
<a class="anchor" id="a8e7348a2205d31179717e6dd7dea0694"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the incremental (matrix) product.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="aad58a24d7a320005a764a8ef80dcd5e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sparse_op.html">SparseOp</a> <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns sum of <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> instances.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="af5f4eec670d91a94d95c1ed1552175bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Incremental sum.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="a4cd0e808c7300e2cd01b86c7150ec679"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sparse_op.html">SparseOp</a> <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the difference of two <a class="el" href="class_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators. ">SparseOp</a> instances.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="abb49fdd7ab7ec59a3097a393cb9d5738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the incremental difference.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

</div>
</div>
<a class="anchor" id="a885f7e0ded73ead4a67e9d048b7179f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The left hand side is initialized with the values of the right hand side. If the left hand side is a null instance, then the left hand is initialized as a duplicate.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked when the left hand side is a non-null instance. </p>

</div>
</div>
<a class="anchor" id="aedb66a97025838deaac9554e65c58e39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::printMatrix </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;%10.5e&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Displays the matrix to the console. The optional input format string specifies the format of a single entry using C printf output conventions. </p>

</div>
</div>
<a class="anchor" id="a21d126b1dae39b2b6ea99fcee78aa435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::printMatrixStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A routine that displays the structure of the matrix as a collection of "+" for non-zero values and "-" for zero values. Due to the aspect ratio of display screens, the display of a square matrix will not be square. </p>

</div>
</div>
<a class="anchor" id="a08c46197946c939959c4404092b5ec7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::setOperatorData </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coeffValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies the value of of the (rowIndex,colIndex) element of the matrix. Any existing value is overwritten. If a non-zero value of dropTolerance is specified, then this operator is a no-op when </p>
<pre>
abs(coeffValue) &lt; dropTolerance
</pre><p> e.g. the value is ignored. </p>

</div>
</div>
<a class="anchor" id="ae1da7fa4c808b143397f6effd5ec0d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt;::sortColumnIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This routine sorts the elements of each row so that the list of column indices associated with each non-zero element in each row are in increasing order. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a0a5df52b1241d98efc2196b6571df336"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sparse_op.html">SparseOp</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SparseOp/<a class="el" href="_sparse_op_8h_source.html">SparseOp.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 29 2016 13:21:09 for 270C_Classes by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
